name: Process Deployment Queue

on:
  schedule:
    # Runs every 30 minutes from 9 AM to 5 PM (NL time) from Monday to Friday
    - cron: "0,30 8-16 * * 1-5"  # Adjusted for CET/CEST timezone (UTC)
  workflow_dispatch:  # Allows manual triggering

jobs:
  process-queue:
    runs-on: ubuntu-latest

    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      JENKINS_URL: ${{ secrets.JENKINS_URL }}  # Store Jenkins URL as a secret
      JENKINS_USER: ${{ secrets.JENKINS_USER }}  # Store Jenkins user credentials
      JENKINS_TOKEN: ${{ secrets.JENKINS_TOKEN }}  # Store Jenkins API token

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Git user identity
      - name: Set up Git user
        run: |
          git config --global user.name "Ysoll"
          git config --global user.email "voda.cristian94@gmail.com"

      # Step 3: Configure Git to use GITHUB_TOKEN for authentication
      - name: Set up Git authentication
        run: |
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      # Step 4: Read queue and get the first RC branch (FIFO)
      - name: Read queue and get the first RC branch
        id: get_queue
        run: |
          if [ ! -s rc_queue.json ]; then
            echo "No branches in the queue"
            exit 0
          fi
          queue_branch=$(jq -r '.queue[0]' rc_queue.json)
          echo "Picked branch: $queue_branch"
          echo "::set-output name=branch::$queue_branch"

      # Step 5: Sync remote RC branch with master and allow unrelated histories
      - name: Sync remote RC branch with master
        id: merge_master
        run: |
          branch="${{ steps.get_queue.outputs.branch }}"
          set +e  # Disable automatic exit on error

          # Fetch all branches from origin
          git fetch origin

          # Check if the branch exists in origin, and work with the remote branch directly
          if git ls-remote --heads origin $branch | grep $branch; then
            echo "Remote branch $branch exists, checking it out."

            # Create a local tracking branch from the remote branch
            git checkout -b $branch origin/$branch

            # Pull the latest changes from the remote branch
            git pull --rebase origin $branch || exit 1
          else
            echo "Remote branch $branch does not exist, creating it."
            git checkout -b $branch
          fi

          # Push the branch to remote
          git push origin $branch || exit 1

          # Merge master into the branch with --allow-unrelated-histories flag
          git fetch origin master
          git merge origin/master --no-edit --allow-unrelated-histories

          if [ $? -ne 0 ]; then
            echo "Merge conflict detected in branch: $branch, aborting."
            echo "::set-output name=conflict::true"
            exit 1  # Exit with error code to indicate a failure
          else
            echo "::set-output name=conflict::false"
          fi
        continue-on-error: true  # Allow the workflow to continue even if there's an error

      # Step 6: Create a release branch from the synced RC branch
      - name: Create release branch
        id: create_release
        if: ${{ steps.merge_master.outputs.conflict == 'false' }}
        run: |
          branch="${{ steps.get_queue.outputs.branch }}"
          date=$(date +'%Y%m%d')
          release_branch="release/fast/$date-$branch"
          git checkout -b $release_branch
          git push origin $release_branch
          echo "::set-output name=release_branch::$release_branch"

      # Step 7: Trigger Jenkins deployment using the release branch
      - name: Trigger Jenkins deployment
        if: ${{ steps.create_release.outputs.release_branch }}
        run: |
          release_branch="${{ steps.create_release.outputs.release_branch }}"
          curl -X POST "${{ env.JENKINS_URL }}/job/deployment-job/buildWithParameters" \
            --user "${{ env.JENKINS_USER }}:${{ env.JENKINS_TOKEN }}" \
            --data "BRANCH_NAME=$release_branch"

      # Step 8: Create a pull request from release branch to master
      - name: Create a pull request
        if: ${{ steps.create_release.outputs.release_branch }}
        id: create_pr
        run: |
          release_branch="${{ steps.create_release.outputs.release_branch }}"
          pr_response=$(gh pr create --base master --head $release_branch --title "Merge $release_branch into master" --body "Automated PR for merging $release_branch into master.")
          pr_url=$(echo "$pr_response" | grep 'http' | awk '{print $1}')
          echo "::set-output name=pr_url::$pr_url"

      # Step 9: Merge the pull request
      - name: Merge pull request
        if: ${{ steps.create_pr.outputs.pr_url }}
        run: |
          pr_url="${{ steps.create_pr.outputs.pr_url }}"
          gh pr merge --auto --delete-branch --squash "$pr_url"

      # Step 10: Remove the RC branch from the queue and mark as deployed
      - name: Remove branch from queue and mark as deployed
        run: |
          branch="${{ steps.get_queue.outputs.branch }}"
          jq 'del(.queue[0])' rc_queue.json > temp.json && mv temp.json rc_queue.json
          git add rc_queue.json
          git commit -m "Removed $branch from queue and marked as deployed"
          git push origin main
          echo "Successfully deployed and removed branch: $branch"

      # Step 11: Commit and push queue changes after processing
      - name: Commit and push changes to the queue
        run: |
          # Remove the first branch from the queue after successfully processing it
          jq 'del(.queue[0])' rc_queue.json > temp.json && mv temp.json rc_queue.json
          git add rc_queue.json
          git commit -m "Removed successfully processed branch: ${{ steps.get_queue.outputs.branch }}"
          git push origin main

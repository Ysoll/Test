name: Process Deployment Queue

on:
  schedule:
    # Runs every 30 minutes from 9 AM to 5 PM (NL time) from Monday to Friday
    - cron: "0,30 8-16 * * 1-5"  # Adjusted for CET/CEST timezone (UTC)
  workflow_dispatch:  # Allows manual triggering

jobs:
  process-queue:
    runs-on: ubuntu-latest

    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      JENKINS_URL: ${{ secrets.JENKINS_URL }}  # Use ngrok or public URL
      JENKINS_USER: ${{ secrets.JENKINS_USER }}  # Store Jenkins user credentials
      JENKINS_TOKEN: ${{ secrets.JENKINS_TOKEN }}  # Store Jenkins API token

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Git user identity
      - name: Set up Git user
        run: |
          git config --global user.name "Ysoll"
          git config --global user.email "voda.cristian94@gmail.com"

      # Step 3: Configure Git to use GITHUB_TOKEN for authentication
      - name: Set up Git authentication
        run: |
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      # Step 4: Read queue and get the first RC branch (FIFO)
      - name: Read queue and get the first RC branch
        id: get_queue
        run: |
          if [ ! -s rc_queue.json ]; then
            echo "No branches in the queue"
            exit 0
          fi
          queue_branch=$(jq -r '.queue[0]' rc_queue.json)
          echo "Picked branch: $queue_branch"
          echo "branch=$queue_branch" >> $GITHUB_ENV

      # Step 5: Sync remote RC branch with master
      - name: Sync remote RC branch with master
        id: merge_master
        run: |
          branch="${{ env.branch }}"
          set +e  # Disable automatic exit on error

          # Fetch all branches from origin
          git fetch origin

          # Check if the branch exists in origin, and work with the remote branch directly
          if git ls-remote --heads origin $branch | grep $branch; then
            echo "Remote branch $branch exists, checking it out."
            git checkout -b $branch origin/$branch
            git pull --rebase origin $branch || exit 1
          else
            echo "Remote branch $branch does not exist, creating it."
            git checkout -b $branch
          fi

          # Push the branch to remote
          git push origin $branch || exit 1

          # Merge master into the branch with the "theirs" strategy
          git fetch origin master
          git merge -X theirs origin/master --no-edit --allow-unrelated-histories || {
              echo "Merge conflict detected in branch: $branch, aborting."
              echo "conflict=true" >> $GITHUB_ENV
              git merge --abort  # Abort the merge in case of conflict
              exit 1
          }

          echo "conflict=false" >> $GITHUB_ENV
        continue-on-error: true  # Allow the workflow to continue even if there's an error

      # Step 6: Handle merge conflict and skip to the next branch
      - name: Skip to the next branch if conflict
        if: ${{ env.conflict == 'true' }}
        run: |
          branch="${{ env.branch }}"
          jq 'del(.queue[0])' rc_queue.json > temp.json && mv temp.json rc_queue.json
          git add rc_queue.json
          git commit -m "Removed $branch due to merge conflict"
          git push origin main
          echo "Skipped branch: $branch due to conflict, picking the next branch."

      # Step 7: Process the next branch if no conflict
      - name: Continue with next branch if no conflict
        if: ${{ env.conflict == 'false' }}
        run: |
          echo "Successfully processed branch: ${{ env.branch }}"
          # Continue your deployment or next steps

      # Step 8: Create release branch from synced RC branch with correct naming convention
      - name: Create release branch
        id: create_release
        if: ${{ env.conflict == 'false' }}
        run: |
          branch="${{ env.branch }}"
          # Extract the last part of the RC branch name (e.g., "rc_test_deployment" from "rc/core_us_test_deployment")
          rc_name=$(basename $branch)
          # Get current date in yyyy-mm-dd format
          date=$(date +'%Y-%m-%d')
          # Form release branch name: release/fast/yyyy-mm-dd_rc_name
          release_branch="release/fast/$date_$rc_name"
          git checkout -b $release_branch
          git push origin $release_branch
          echo "release_branch=$release_branch" >> $GITHUB_ENV

      # Step 9: Trigger Jenkins deployment using release branch
      - name: Trigger Jenkins deployment
        if: ${{ env.release_branch }}
        run: |
          release_branch="${{ env.release_branch }}"
          jenkins_url="${{ env.JENKINS_URL }}"
          if [ -z "$jenkins_url" ] || [ -z "$release_branch" ]; then
            echo "Jenkins URL or release branch is missing."
            exit 1
          fi

          # Trigger Jenkins job
          curl -X POST "$jenkins_url/job/JenkinsTest/buildWithParameters" \
            --user "${{ env.JENKINS_USER }}:${{ env.JENKINS_TOKEN }}" \
            --data-urlencode "BRANCH_NAME=$release_branch" || {
              echo "Failed to trigger Jenkins job for $release_branch"
              exit 1
          }

      # Step 10: Create pull request from release branch to master
      - name: Create a pull request
        if: ${{ env.release_branch }}
        id: create_pr
        run: |
          release_branch="${{ env.release_branch }}"
          pr_response=$(gh pr create --base master --head $release_branch --title "Merge $release_branch into master" --body "Automated PR for merging $release_branch into master.")
          pr_url=$(echo "$pr_response" | grep 'http' | awk '{print $1}')
          echo "pr_url=$pr_url" >> $GITHUB_ENV

      # Step 11: Merge the pull request
      - name: Merge pull request
        if: ${{ env.pr_url }}
        run: |
          pr_url="${{ env.pr_url }}"
          gh pr merge --auto --delete-branch --squash "$pr_url"

      # Step 12: Remove the RC branch from the queue and mark as deployed
      - name: Remove branch from queue and mark as deployed
        run: |
          branch="${{ env.branch }}"
          jq 'del(.queue[0])' rc_queue.json > temp.json && mv temp.json rc_queue.json
          git add rc_queue.json
          git commit -m "Removed $branch from queue and marked as deployed"
          git push origin main
          echo "Successfully deployed and removed branch: $branch"
